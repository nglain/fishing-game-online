<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>–†—ã–±–∞–ª–∫–∞ –û–Ω–ª–∞–π–Ω</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(180deg, #1a5276 0%, #0e2f44 100%);
            min-height: 100vh;
            overflow: hidden;
            touch-action: manipulation;
        }

        /* –ú–ï–ù–Æ */
        .menu {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(180deg, #87CEEB 0%, #4682B4 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
        }

        .menu.hidden { display: none; }

        .menu h1 {
            font-size: 72px;
            color: #fff;
            text-shadow: 3px 3px 6px rgba(0,0,0,0.3);
            margin-bottom: 10px;
        }

        .menu h2 {
            font-size: 28px;
            color: rgba(255,255,255,0.8);
            margin-bottom: 40px;
        }

        .menu-box {
            background: rgba(255,255,255,0.15);
            backdrop-filter: blur(10px);
            padding: 40px;
            border-radius: 20px;
            text-align: center;
        }

        .menu input {
            width: 300px;
            padding: 15px 20px;
            font-size: 18px;
            border: none;
            border-radius: 30px;
            margin-bottom: 20px;
            text-align: center;
            outline: none;
        }

        .menu button {
            width: 300px;
            padding: 18px;
            font-size: 22px;
            border: none;
            border-radius: 30px;
            background: linear-gradient(180deg, #2ecc71 0%, #27ae60 100%);
            color: white;
            cursor: pointer;
            font-weight: bold;
            box-shadow: 0 5px 20px rgba(46, 204, 113, 0.4);
        }

        .online-count {
            margin-top: 20px;
            color: rgba(255,255,255,0.7);
        }

        /* –ò–ì–†–ê */
        .game { display: none; width: 100%; height: 100vh; }
        .game.active { display: block; }
        #pond { width: 100%; height: 100%; cursor: crosshair; }

        /* –í–µ—Ä—Ö–Ω—è—è –ø–∞–Ω–µ–ª—å —Å —Ä–∞—É–Ω–¥–æ–º –∏ —Ç–∞–π–º–µ—Ä–æ–º */
        .top-bar {
            position: fixed;
            top: 0;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.8);
            padding: 10px 30px;
            border-radius: 0 0 20px 20px;
            color: white;
            text-align: center;
            z-index: 50;
        }

        .round-info {
            font-size: 14px;
            opacity: 0.8;
        }

        .timer {
            font-size: 32px;
            font-weight: bold;
            color: #2ecc71;
        }

        .timer.warning { color: #f1c40f; }
        .timer.danger { color: #e74c3c; animation: blink 0.5s infinite; }

        @keyframes blink {
            50% { opacity: 0.5; }
        }

        /* HUD */
        .hud {
            position: fixed;
            top: 80px;
            left: 20px;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .hud-box {
            background: rgba(0,0,0,0.6);
            padding: 10px 15px;
            border-radius: 12px;
            color: white;
        }

        .hud-box h4 { font-size: 10px; opacity: 0.7; }
        .hud-box p { font-size: 16px; font-weight: bold; }

        /* –ò–≥—Ä–æ–∫–∏ */
        .players-list {
            position: fixed;
            top: 80px;
            right: 20px;
            background: rgba(0,0,0,0.6);
            padding: 12px;
            border-radius: 12px;
            color: white;
            min-width: 150px;
        }

        .players-list h3 { font-size: 13px; margin-bottom: 8px; }

        .player-item {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 4px 0;
            font-size: 12px;
        }

        .player-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
        }

        /* –õ–µ–Ω—Ç–∞ */
        .feed {
            position: fixed;
            bottom: 20px;
            left: 20px;
            width: 250px;
        }

        .feed-item {
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 8px 12px;
            border-radius: 8px;
            margin-top: 6px;
            font-size: 12px;
            animation: slideIn 0.3s ease;
        }

        @keyframes slideIn {
            from { opacity: 0; transform: translateX(-20px); }
            to { opacity: 1; transform: translateX(0); }
        }

        /* Popup */
        .catch-popup {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0);
            background: rgba(0,0,0,0.9);
            color: white;
            padding: 25px 40px;
            border-radius: 20px;
            font-size: 24px;
            z-index: 50;
            text-align: center;
            transition: transform 0.3s ease;
        }

        .catch-popup.show { transform: translate(-50%, -50%) scale(1); }
        .catch-popup .fish-emoji { font-size: 50px; display: block; margin-bottom: 10px; }

        /* –≠–∫—Ä–∞–Ω —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ —Ä–∞—É–Ω–¥–∞ */
        .round-result {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.9);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 90;
            color: white;
        }

        .round-result.show { display: flex; }

        .round-result h2 {
            font-size: 36px;
            margin-bottom: 20px;
            color: #f1c40f;
        }

        .round-result h3 {
            font-size: 20px;
            margin-bottom: 15px;
            opacity: 0.8;
        }

        .result-list {
            background: rgba(255,255,255,0.1);
            padding: 20px;
            border-radius: 15px;
            min-width: 300px;
        }

        .result-item {
            display: flex;
            align-items: center;
            gap: 15px;
            padding: 10px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }

        .result-item:last-child { border-bottom: none; }

        .result-rank {
            font-size: 24px;
            font-weight: bold;
            width: 40px;
        }

        .result-rank.gold { color: #ffd700; }
        .result-rank.silver { color: #c0c0c0; }
        .result-rank.bronze { color: #cd7f32; }

        .result-name { flex: 1; }
        .result-score { font-weight: bold; color: #2ecc71; }

        .next-round-timer {
            margin-top: 20px;
            font-size: 18px;
            opacity: 0.7;
        }

        /* –ú–ò–ù–ò-–ò–ì–†–ê */
        .minigame {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 80;
        }

        .minigame.active { display: flex; }

        .minigame-title {
            color: #f1c40f;
            font-size: 28px;
            margin-bottom: 10px;
            animation: pulse 0.5s ease infinite alternate;
        }

        @keyframes pulse {
            from { transform: scale(1); }
            to { transform: scale(1.1); }
        }

        .minigame-timer {
            width: 300px;
            height: 10px;
            background: rgba(255,255,255,0.2);
            border-radius: 5px;
            margin-bottom: 30px;
            overflow: hidden;
        }

        .minigame-timer-bar {
            height: 100%;
            background: linear-gradient(90deg, #2ecc71, #f1c40f, #e74c3c);
            transition: width 0.1s linear;
        }

        .minigame-progress { color: white; font-size: 18px; margin-bottom: 20px; }

        .minigame-progress-bar {
            width: 250px;
            height: 20px;
            background: rgba(255,255,255,0.2);
            border-radius: 10px;
            overflow: hidden;
            margin-top: 10px;
        }

        .minigame-progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #3498db, #2ecc71);
            transition: width 0.2s ease;
            width: 0%;
        }

        .minigame-key {
            width: 100px;
            height: 100px;
            background: linear-gradient(180deg, #3498db 0%, #2980b9 100%);
            border-radius: 15px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 48px;
            font-weight: bold;
            color: white;
            box-shadow: 0 6px 0 #1a5276;
        }

        .minigame-key.pressed { transform: translateY(4px); box-shadow: 0 2px 0 #1a5276; }
        .minigame-key.correct { background: linear-gradient(180deg, #2ecc71 0%, #27ae60 100%); }
        .minigame-key.wrong { background: linear-gradient(180deg, #e74c3c 0%, #c0392b 100%); }

        .minigame-mobile-buttons {
            display: none;
            gap: 20px;
            flex-wrap: wrap;
            justify-content: center;
            max-width: 350px;
        }

        .minigame-mobile-btn {
            width: 140px;
            height: 80px;
            background: linear-gradient(180deg, #e74c3c 0%, #c0392b 100%);
            border: none;
            border-radius: 15px;
            font-size: 22px;
            font-weight: bold;
            color: white;
            box-shadow: 0 5px 0 #922b21;
        }

        .minigame-mobile-btn.highlight {
            background: linear-gradient(180deg, #f1c40f 0%, #f39c12 100%);
            animation: btnPulse 0.3s ease infinite alternate;
        }

        @keyframes btnPulse {
            from { transform: scale(1); }
            to { transform: scale(1.05); }
        }

        @media (max-width: 600px) {
            .menu h1 { font-size: 48px; }
            .menu input, .menu button { width: 250px; }
            .top-bar { padding: 8px 20px; }
            .timer { font-size: 24px; }
            .hud { top: 70px; left: 10px; }
            .players-list { top: 70px; right: 10px; padding: 8px; }
            .minigame-key { display: none; }
            .minigame-mobile-buttons { display: flex; }
        }

        @media (min-width: 601px) {
            .minigame-mobile-buttons { display: none; }
        }

        .hint {
            position: fixed;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.6);
            color: rgba(255,255,255,0.8);
            padding: 10px 20px;
            border-radius: 20px;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <!-- –ú–ï–ù–Æ -->
    <div class="menu" id="menu">
        <h1>üé£</h1>
        <h2>–†—ã–±–∞–ª–∫–∞ –û–Ω–ª–∞–π–Ω</h2>
        <div class="menu-box">
            <input type="text" id="playerName" placeholder="–í–≤–µ–¥–∏ –∏–º—è..." maxlength="15">
            <br>
            <button id="playBtn">–ò–≥—Ä–∞—Ç—å</button>
        </div>
        <p class="online-count">–û–Ω–ª–∞–π–Ω: <span id="onlineCount">0</span></p>
    </div>

    <!-- –ò–ì–†–ê -->
    <div class="game" id="game">
        <canvas id="pond"></canvas>

        <div class="top-bar">
            <div class="round-info">–†–∞—É–Ω–¥ <span id="currentRound">1</span> / <span id="totalRounds">10</span></div>
            <div class="timer" id="timer">2:00</div>
        </div>

        <div class="hud">
            <div class="hud-box">
                <h4>–†–∞—É–Ω–¥</h4>
                <p><span id="roundFish">0</span> üêü <span id="roundWeight">0</span> –∫–≥</p>
            </div>
            <div class="hud-box">
                <h4>–í—Å–µ–≥–æ</h4>
                <p><span id="totalFish">0</span> üêü <span id="totalWeight">0</span> –∫–≥</p>
            </div>
        </div>

        <div class="players-list">
            <h3>üë• –ò–≥—Ä–æ–∫–∏</h3>
            <div id="playersContainer"></div>
        </div>

        <div class="feed" id="feed"></div>

        <div class="catch-popup" id="catchPopup">
            <span class="fish-emoji" id="popupEmoji">üêü</span>
            <span id="popupText">–ö–∞—Ä–∞—Å—å 0.5 –∫–≥</span>
        </div>

        <div class="hint" id="hint">–ö–ª–∏–∫–Ω–∏ –Ω–∞ –≤–æ–¥—É</div>
    </div>

    <!-- –†–µ–∑—É–ª—å—Ç–∞—Ç—ã —Ä–∞—É–Ω–¥–∞ -->
    <div class="round-result" id="roundResult">
        <h2 id="resultTitle">–†–∞—É–Ω–¥ 1 –∑–∞–≤–µ—Ä—à—ë–Ω!</h2>
        <h3>–†–µ–∑—É–ª—å—Ç–∞—Ç—ã —Ä–∞—É–Ω–¥–∞:</h3>
        <div class="result-list" id="roundRanking"></div>
        <div class="next-round-timer" id="nextRoundTimer">–°–ª–µ–¥—É—é—â–∏–π —Ä–∞—É–Ω–¥ —á–µ—Ä–µ–∑ 10 —Å–µ–∫...</div>
    </div>

    <!-- –ú–ò–ù–ò-–ò–ì–†–ê -->
    <div class="minigame" id="minigame">
        <div class="minigame-title" id="minigameTitle">üêü –ö–ª—é—ë—Ç!</div>
        <div class="minigame-timer">
            <div class="minigame-timer-bar" id="timerBar"></div>
        </div>
        <div class="minigame-progress">
            <span>–¢—è–Ω–∏!</span>
            <div class="minigame-progress-bar">
                <div class="minigame-progress-fill" id="progressFill"></div>
            </div>
        </div>
        <div class="minigame-key" id="minigameKey">W</div>
        <div class="minigame-mobile-buttons">
            <button class="minigame-mobile-btn" data-btn="1">–ñ–ú–ò!</button>
            <button class="minigame-mobile-btn" data-btn="2">–ñ–ú–ò!</button>
            <button class="minigame-mobile-btn" data-btn="3">–ñ–ú–ò!</button>
            <button class="minigame-mobile-btn" data-btn="4">–ñ–ú–ò!</button>
        </div>
    </div>

    <script src="/socket.io/socket.io.js"></script>
    <script>
        const menu = document.getElementById('menu');
        const game = document.getElementById('game');
        const playerNameInput = document.getElementById('playerName');
        const playBtn = document.getElementById('playBtn');
        const onlineCount = document.getElementById('onlineCount');
        const canvas = document.getElementById('pond');
        const ctx = canvas.getContext('2d');
        const playersContainer = document.getElementById('playersContainer');
        const feed = document.getElementById('feed');
        const catchPopup = document.getElementById('catchPopup');
        const popupEmoji = document.getElementById('popupEmoji');
        const popupText = document.getElementById('popupText');
        const hint = document.getElementById('hint');

        const currentRoundEl = document.getElementById('currentRound');
        const totalRoundsEl = document.getElementById('totalRounds');
        const timerEl = document.getElementById('timer');
        const roundFishEl = document.getElementById('roundFish');
        const roundWeightEl = document.getElementById('roundWeight');
        const totalFishEl = document.getElementById('totalFish');
        const totalWeightEl = document.getElementById('totalWeight');

        const roundResult = document.getElementById('roundResult');
        const resultTitle = document.getElementById('resultTitle');
        const roundRanking = document.getElementById('roundRanking');
        const nextRoundTimer = document.getElementById('nextRoundTimer');

        const minigame = document.getElementById('minigame');
        const minigameTitle = document.getElementById('minigameTitle');
        const timerBar = document.getElementById('timerBar');
        const progressFill = document.getElementById('progressFill');
        const minigameKey = document.getElementById('minigameKey');

        const socket = io();

        let myPlayer = null;
        let players = new Map();
        let isFishing = false;
        let isMinigameActive = false;
        let bobberX = 0, bobberY = 0;
        let waves = [], bubbles = [], fishInWater = [];
        let pendingFish = null;
        let gameActive = false;

        let minigameProgress = 0, minigameTimer = 0, minigameInterval = null;
        let currentKey = '', currentButton = 0;
        let correctPresses = 0;
        const maxPresses = 6;
        const keys = ['W', 'A', 'S', 'D'];

        const isMobile = /Android|iPhone|iPad|iPod/i.test(navigator.userAgent) || window.innerWidth < 601;

        const fishTypes = [
            { name: '–ö–∞—Ä–∞—Å—å', emoji: 'üêü', minWeight: 0.1, maxWeight: 0.5, rarity: 0.28, difficulty: 3 },
            { name: '–û–∫—É–Ω—å', emoji: 'üê†', minWeight: 0.2, maxWeight: 0.8, rarity: 0.20, difficulty: 4 },
            { name: '–©—É–∫–∞', emoji: 'üê°', minWeight: 0.5, maxWeight: 3.0, rarity: 0.12, difficulty: 6 },
            { name: '–°–æ–º', emoji: 'üêã', minWeight: 2.0, maxWeight: 10.0, rarity: 0.06, difficulty: 8 },
            { name: '–õ–µ—â', emoji: 'üêü', minWeight: 0.3, maxWeight: 1.5, rarity: 0.10, difficulty: 5 },
            { name: '–ó–æ–ª–æ—Ç–∞—è —Ä—ã–±–∫–∞', emoji: '‚ú®', minWeight: 0.1, maxWeight: 0.2, rarity: 0.02, difficulty: 10 },
            { name: '–ù–æ–≤–æ–≥–æ–¥–Ω—è—è —Ä—ã–±–∞', emoji: 'üéÑ', minWeight: 1.0, maxWeight: 5.0, rarity: 0.08, difficulty: 7 },
            { name: '–°–Ω–µ–∂–Ω–∞—è —Ä—ã–±–∞', emoji: '‚ùÑÔ∏è', minWeight: 0.5, maxWeight: 2.0, rarity: 0.06, difficulty: 6 },
            { name: '–î–µ–¥ –ú–æ—Ä–æ–∑', emoji: 'üéÖ', minWeight: 3.0, maxWeight: 8.0, rarity: 0.04, difficulty: 9 },
            { name: '–ü–æ–¥–∞—Ä–æ–∫', emoji: 'üéÅ', minWeight: 0.2, maxWeight: 1.0, rarity: 0.02, difficulty: 5 },
            { name: '–°—Ç–∞—Ä—ã–π –±–æ—Ç–∏–Ω–æ–∫', emoji: 'üë¢', minWeight: 0.5, maxWeight: 0.5, rarity: 0.02, difficulty: 1 }
        ];

        let stats = { fishCount: 0, totalWeight: 0, roundFish: 0, roundWeight: 0 };

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        for (let i = 0; i < 8; i++) {
            waves.push({ offset: Math.random() * Math.PI * 2, speed: 0.01 + Math.random() * 0.02, y: i * 100 });
        }

        function addFishToWater() {
            for (let i = 0; i < 8; i++) {
                fishInWater.push({
                    x: Math.random() * canvas.width,
                    y: 150 + Math.random() * (canvas.height - 250),
                    emoji: ['üêü', 'üê†'][Math.floor(Math.random() * 2)],
                    size: 20 + Math.random() * 20,
                    speedX: (Math.random() - 0.5) * 1.5
                });
            }
        }

        // –°–Ω–µ–∂–∏–Ω–∫–∏
        let snowflakes = [];
        for (let i = 0; i < 50; i++) {
            snowflakes.push({
                x: Math.random() * 2000,
                y: Math.random() * 1000,
                size: 2 + Math.random() * 4,
                speed: 0.3 + Math.random() * 0.5,
                drift: Math.random() * 0.5 - 0.25
            });
        }

        function drawSnowflakes() {
            ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
            snowflakes.forEach(flake => {
                ctx.beginPath();
                ctx.arc(flake.x, flake.y, flake.size, 0, Math.PI * 2);
                ctx.fill();

                flake.y += flake.speed;
                flake.x += flake.drift + Math.sin(Date.now() * 0.001 + flake.x) * 0.3;

                if (flake.y > canvas.height) {
                    flake.y = -10;
                    flake.x = Math.random() * canvas.width;
                }
                if (flake.x > canvas.width) flake.x = 0;
                if (flake.x < 0) flake.x = canvas.width;
            });
        }

        function drawUnderwaterTree(x, baseY) {
            // –°—Ç–≤–æ–ª
            ctx.fillStyle = '#5D4037';
            ctx.fillRect(x - 8, baseY - 20, 16, 30);

            // –Å–ª–∫–∞ (3 —è—Ä—É—Å–∞)
            ctx.fillStyle = '#1B5E20';

            // –ù–∏–∂–Ω–∏–π —è—Ä—É—Å
            ctx.beginPath();
            ctx.moveTo(x - 50, baseY - 20);
            ctx.lineTo(x + 50, baseY - 20);
            ctx.lineTo(x, baseY - 80);
            ctx.closePath();
            ctx.fill();

            // –°—Ä–µ–¥–Ω–∏–π —è—Ä—É—Å
            ctx.beginPath();
            ctx.moveTo(x - 40, baseY - 60);
            ctx.lineTo(x + 40, baseY - 60);
            ctx.lineTo(x, baseY - 110);
            ctx.closePath();
            ctx.fill();

            // –í–µ—Ä—Ö–Ω–∏–π —è—Ä—É—Å
            ctx.beginPath();
            ctx.moveTo(x - 25, baseY - 95);
            ctx.lineTo(x + 25, baseY - 95);
            ctx.lineTo(x, baseY - 135);
            ctx.closePath();
            ctx.fill();

            // –ó–≤–µ–∑–¥–∞ –Ω–∞ –≤–µ—Ä—Ö—É—à–∫–µ
            ctx.fillStyle = '#FFD700';
            ctx.font = '20px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('‚≠ê', x, baseY - 135);

            // –ì–∏—Ä–ª—è–Ω–¥—ã (–º–∏–≥–∞—é—â–∏–µ —à–∞—Ä–∏–∫–∏)
            const colors = ['#e74c3c', '#f1c40f', '#3498db', '#9b59b6', '#2ecc71'];
            const time = Date.now() * 0.003;

            for (let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 2 + time;
                const radius = 25 + (i % 3) * 15;
                const ballX = x + Math.cos(angle) * radius * 0.8;
                const ballY = baseY - 50 - (i % 3) * 30 + Math.sin(angle) * 5;

                ctx.fillStyle = colors[i % colors.length];
                ctx.globalAlpha = 0.7 + Math.sin(time + i) * 0.3;
                ctx.beginPath();
                ctx.arc(ballX, ballY, 5, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.globalAlpha = 1;
        }

        function draw() {
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, '#1a5276');
            gradient.addColorStop(0.5, '#154360');
            gradient.addColorStop(1, '#0e2f44');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.strokeStyle = 'rgba(255,255,255,0.08)';
            ctx.lineWidth = 2;
            waves.forEach(wave => {
                ctx.beginPath();
                for (let x = 0; x < canvas.width; x += 5) {
                    const waveY = wave.y + Math.sin(x * 0.015 + wave.offset) * 15;
                    if (x === 0) ctx.moveTo(x, waveY);
                    else ctx.lineTo(x, waveY);
                }
                ctx.stroke();
                wave.offset += wave.speed;
            });

            // –ù–æ–≤–æ–≥–æ–¥–Ω—è—è —ë–ª–∫–∞ –ø–æ–¥ –≤–æ–¥–æ–π
            drawUnderwaterTree(canvas.width * 0.15, canvas.height - 50);
            drawUnderwaterTree(canvas.width * 0.85, canvas.height - 30);

            // –°–Ω–µ–∂–∏–Ω–∫–∏
            drawSnowflakes();

            fishInWater.forEach(fish => {
                ctx.font = `${fish.size}px Arial`;
                ctx.save();
                if (fish.speedX < 0) {
                    ctx.scale(-1, 1);
                    ctx.fillText(fish.emoji, -fish.x - fish.size, fish.y);
                } else {
                    ctx.fillText(fish.emoji, fish.x, fish.y);
                }
                ctx.restore();
                fish.x += fish.speedX;
                if (fish.x > canvas.width + 50) fish.x = -50;
                if (fish.x < -50) fish.x = canvas.width + 50;
            });

            bubbles.forEach((bubble, i) => {
                ctx.beginPath();
                ctx.arc(bubble.x, bubble.y, bubble.size, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(255,255,255,${bubble.opacity})`;
                ctx.fill();
                bubble.y -= bubble.speed;
                bubble.opacity -= 0.008;
                if (bubble.opacity <= 0) bubbles.splice(i, 1);
            });

            players.forEach((player, id) => {
                if (id !== socket.id && player.isFishing) {
                    drawBobber(player.x, player.y, player.color, player.name);
                }
            });

            if (isFishing) {
                drawBobber(bobberX, bobberY, myPlayer.color, null, true);
            }

            requestAnimationFrame(draw);
        }

        function drawBobber(x, y, color, name, isMe = false) {
            const bobY = y + Math.sin(Date.now() * 0.005) * 3;

            ctx.strokeStyle = 'rgba(255,255,255,0.3)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(x, 0);
            ctx.lineTo(x, bobY - 15);
            ctx.stroke();

            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.ellipse(x, bobY, 8, 14, 0, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.ellipse(x, bobY - 10, 6, 6, 0, 0, Math.PI * 2);
            ctx.fill();

            if (name) {
                ctx.fillStyle = 'rgba(255,255,255,0.9)';
                ctx.font = '12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(name, x, bobY - 30);
            }

            if (isMe && Math.random() < 0.03) {
                bubbles.push({
                    x: x + (Math.random() - 0.5) * 30,
                    y: bobY + 15,
                    size: 2 + Math.random() * 4,
                    speed: 0.5 + Math.random(),
                    opacity: 0.5
                });
            }
        }

        function selectFish() {
            const rand = Math.random();
            if (rand < 0.15) return null;
            const adjustedRand = (rand - 0.15) / 0.85;
            let cumulative = 0;
            for (const fish of fishTypes) {
                cumulative += fish.rarity;
                if (adjustedRand < cumulative) {
                    const weight = fish.minWeight + Math.random() * (fish.maxWeight - fish.minWeight);
                    return { ...fish, weight: Math.round(weight * 100) / 100 };
                }
            }
            return fishTypes[0];
        }

        function showPopup(emoji, text) {
            popupEmoji.textContent = emoji;
            popupText.textContent = text;
            catchPopup.classList.add('show');
            setTimeout(() => catchPopup.classList.remove('show'), 2000);
        }

        function addFeedItem(text) {
            const item = document.createElement('div');
            item.className = 'feed-item';
            item.textContent = text;
            feed.appendChild(item);
            if (feed.children.length > 5) feed.removeChild(feed.firstChild);
            setTimeout(() => { if (item.parentNode) item.remove(); }, 5000);
        }

        function updatePlayersList() {
            playersContainer.innerHTML = '';
            const sorted = Array.from(players.values()).sort((a, b) => (b.roundWeight || 0) - (a.roundWeight || 0));
            sorted.forEach((player) => {
                const div = document.createElement('div');
                div.className = 'player-item';
                div.innerHTML = `
                    <span class="player-dot" style="background: ${player.color}"></span>
                    <span>${player.name}${player.id === socket.id ? ' (—Ç—ã)' : ''}</span>
                    <span style="margin-left: auto">${(player.roundWeight || 0).toFixed(1)}</span>
                `;
                playersContainer.appendChild(div);
            });
            onlineCount.textContent = players.size;
        }

        function updateStats() {
            roundFishEl.textContent = stats.roundFish;
            roundWeightEl.textContent = stats.roundWeight.toFixed(1);
            totalFishEl.textContent = stats.fishCount;
            totalWeightEl.textContent = stats.totalWeight.toFixed(1);
        }

        function formatTime(seconds) {
            const m = Math.floor(seconds / 60);
            const s = seconds % 60;
            return `${m}:${s.toString().padStart(2, '0')}`;
        }

        function updateTimer(timeLeft, isBreak) {
            timerEl.textContent = formatTime(timeLeft);
            timerEl.className = 'timer';
            if (!isBreak) {
                if (timeLeft <= 10) timerEl.classList.add('danger');
                else if (timeLeft <= 30) timerEl.classList.add('warning');
            }
        }

        function showRoundResult(data) {
            resultTitle.textContent = data.isGameEnd
                ? 'üèÜ –ò–≥—Ä–∞ –æ–∫–æ–Ω—á–µ–Ω–∞!'
                : `–†–∞—É–Ω–¥ ${data.round} –∑–∞–≤–µ—Ä—à—ë–Ω!`;

            const ranking = data.isGameEnd ? data.totalRanking : data.ranking;

            roundRanking.innerHTML = ranking.slice(0, 5).map((p, i) => `
                <div class="result-item">
                    <span class="result-rank ${i === 0 ? 'gold' : i === 1 ? 'silver' : i === 2 ? 'bronze' : ''}">${i + 1}</span>
                    <span class="result-name" style="color: ${p.color}">${p.name}</span>
                    <span class="result-score">${(data.isGameEnd ? p.totalWeight : p.roundWeight || 0).toFixed(1)} –∫–≥</span>
                </div>
            `).join('');

            nextRoundTimer.textContent = data.isGameEnd
                ? '–ù–æ–≤–∞—è –∏–≥—Ä–∞ —á–µ—Ä–µ–∑ 15 —Å–µ–∫...'
                : '–°–ª–µ–¥—É—é—â–∏–π —Ä–∞—É–Ω–¥ —á–µ—Ä–µ–∑ 10 —Å–µ–∫...';

            roundResult.classList.add('show');
        }

        function hideRoundResult() {
            roundResult.classList.remove('show');
        }

        // –ú–∏–Ω–∏-–∏–≥—Ä–∞
        function startMinigame(fish) {
            pendingFish = fish;
            isMinigameActive = true;
            minigameProgress = 0;
            minigameTimer = 100;
            correctPresses = 0;

            minigameTitle.textContent = `${fish.emoji} ${fish.name} –∫–ª—é—ë—Ç!`;
            progressFill.style.width = '0%';
            timerBar.style.width = '100%';

            minigame.classList.add('active');
            hint.style.display = 'none';

            socket.emit('pulling');

            if (isMobile) nextMobileButton();
            else nextKey();

            minigameInterval = setInterval(() => {
                minigameTimer -= 0.8;
                timerBar.style.width = minigameTimer + '%';
                if (minigameTimer <= 0) endMinigame(false);
            }, 100);
        }

        function nextKey() {
            currentKey = keys[Math.floor(Math.random() * keys.length)];
            minigameKey.textContent = currentKey;
            minigameKey.className = 'minigame-key';
        }

        function nextMobileButton() {
            document.querySelectorAll('.minigame-mobile-btn').forEach(btn => btn.classList.remove('highlight'));
            currentButton = Math.floor(Math.random() * 4) + 1;
            const btn = document.querySelector(`[data-btn="${currentButton}"]`);
            if (btn) btn.classList.add('highlight');
        }

        function handleMinigameInput(correct) {
            if (!isMinigameActive) return;

            if (correct) {
                correctPresses++;
                minigameProgress = (correctPresses / maxPresses) * 100;
                progressFill.style.width = Math.min(100, minigameProgress) + '%';

                if (isMobile) nextMobileButton();
                else {
                    minigameKey.classList.add('correct');
                    setTimeout(() => { if (isMinigameActive) nextKey(); }, 100);
                }

                if (correctPresses >= maxPresses) endMinigame(true);
            } else {
                if (!isMobile) {
                    minigameKey.classList.add('wrong');
                    setTimeout(() => minigameKey.classList.remove('wrong'), 200);
                }
            }
        }

        function endMinigame(success) {
            clearInterval(minigameInterval);
            isMinigameActive = false;
            minigame.classList.remove('active');
            hint.style.display = 'block';

            document.querySelectorAll('.minigame-mobile-btn').forEach(btn => btn.classList.remove('highlight'));

            if (success && pendingFish) {
                if (pendingFish.name === '–°—Ç–∞—Ä—ã–π –±–æ—Ç–∏–Ω–æ–∫') {
                    showPopup(pendingFish.emoji, '–°—Ç–∞—Ä—ã–π –±–æ—Ç–∏–Ω–æ–∫!');
                } else {
                    stats.fishCount++;
                    stats.totalWeight += pendingFish.weight;
                    stats.roundFish++;
                    stats.roundWeight += pendingFish.weight;
                    showPopup(pendingFish.emoji, `${pendingFish.name} ${pendingFish.weight} –∫–≥`);
                    updateStats();
                }
                socket.emit('caught', { fish: pendingFish });

                for (let i = 0; i < 12; i++) {
                    bubbles.push({
                        x: bobberX + (Math.random() - 0.5) * 50,
                        y: bobberY,
                        size: 3 + Math.random() * 6,
                        speed: 1.5 + Math.random() * 2,
                        opacity: 0.8
                    });
                }
            } else {
                showPopup('üòî', '–°–æ—Ä–≤–∞–ª–æ—Å—å!');
                socket.emit('missed', { reason: 'failed' });
            }

            isFishing = false;
            pendingFish = null;
        }

        document.addEventListener('keydown', (e) => {
            if (!isMinigameActive || isMobile) return;
            const key = e.key.toUpperCase();
            if (keys.includes(key)) {
                minigameKey.classList.add('pressed');
                setTimeout(() => minigameKey.classList.remove('pressed'), 100);
                handleMinigameInput(key === currentKey);
            }
        });

        document.querySelectorAll('.minigame-mobile-btn').forEach(btn => {
            btn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                if (!isMinigameActive) return;
                handleMinigameInput(parseInt(btn.dataset.btn) === currentButton);
            });
        });

        function cast(x, y) {
            if (isFishing || isMinigameActive) return;
            if (!gameActive) {
                showPopup('‚è≥', '–ñ–¥—ë–º –Ω–∞—á–∞–ª–∞ —Ä–∞—É–Ω–¥–∞...');
                return;
            }

            isFishing = true;
            bobberX = x;
            bobberY = y;

            socket.emit('cast', { x, y });

            for (let i = 0; i < 8; i++) {
                bubbles.push({
                    x: x + (Math.random() - 0.5) * 40,
                    y: y,
                    size: 3 + Math.random() * 5,
                    speed: 1 + Math.random() * 2,
                    opacity: 0.7
                });
            }

            const waitTime = 2000 + Math.random() * 3000;
            setTimeout(() => {
                if (!isFishing || !gameActive) return;
                const fish = selectFish();
                if (fish) startMinigame(fish);
                else {
                    showPopup('ü§∑', '–ù–µ –∫–ª—é—ë—Ç...');
                    isFishing = false;
                    socket.emit('missed', { reason: 'no_bite' });
                }
            }, waitTime);
        }

        canvas.addEventListener('click', (e) => {
            if (!myPlayer || isMinigameActive) return;
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            if (y > 60) cast(x, y);
        });

        canvas.addEventListener('touchstart', (e) => {
            if (!myPlayer || isMinigameActive) return;
            e.preventDefault();
            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            const x = touch.clientX - rect.left;
            const y = touch.clientY - rect.top;
            console.log('Touch:', x, y, 'gameActive:', gameActive);
            if (y > 60) cast(x, y);
        }, { passive: false });

        // Socket —Å–æ–±—ã—Ç–∏—è
        socket.on('joined', (data) => {
            myPlayer = data.player;
            data.players.forEach(p => players.set(p.id, p));
            updatePlayersList();

            if (data.gameState) {
                currentRoundEl.textContent = data.gameState.currentRound || 1;
                totalRoundsEl.textContent = data.gameState.totalRounds || 10;
                updateTimer(data.gameState.timeLeft || 120, data.gameState.isBreak);
                gameActive = data.gameState.isActive;
            }
        });

        socket.on('playerJoined', (player) => {
            players.set(player.id, player);
            updatePlayersList();
            addFeedItem(`${player.name} –ø—Ä–∏—Å–æ–µ–¥–∏–Ω–∏–ª—Å—è`);
        });

        socket.on('playerLeft', (id) => {
            const player = players.get(id);
            if (player) addFeedItem(`${player.name} —É—à—ë–ª`);
            players.delete(id);
            updatePlayersList();
        });

        socket.on('playerCast', (data) => {
            const player = players.get(data.id);
            if (player) {
                player.x = data.x;
                player.y = data.y;
                player.isFishing = true;
            }
        });

        socket.on('playerCaught', (data) => {
            const player = players.get(data.id);
            if (player) {
                player.isFishing = false;
                player.roundWeight = data.roundWeight;
                player.roundFish = data.roundFish;
                updatePlayersList();
                if (data.id !== socket.id && data.fish.name !== '–°—Ç–∞—Ä—ã–π –±–æ—Ç–∏–Ω–æ–∫') {
                    addFeedItem(`${data.name} –ø–æ–π–º–∞–ª ${data.fish.emoji} ${data.fish.weight} –∫–≥`);
                }
            }
        });

        socket.on('playerMissed', (data) => {
            const player = players.get(data.id);
            if (player) player.isFishing = false;
        });

        socket.on('gameStarting', (data) => {
            addFeedItem(`–ò–≥—Ä–∞ –Ω–∞—á–Ω—ë—Ç—Å—è —á–µ—Ä–µ–∑ ${data.countdown} —Å–µ–∫...`);
            hideRoundResult();
        });

        socket.on('roundStart', (data) => {
            currentRoundEl.textContent = data.round;
            totalRoundsEl.textContent = data.totalRounds;
            updateTimer(data.timeLeft, false);
            gameActive = true;
            stats.roundFish = 0;
            stats.roundWeight = 0;
            updateStats();
            hideRoundResult();
            addFeedItem(`–†–∞—É–Ω–¥ ${data.round} –Ω–∞—á–∞–ª—Å—è!`);
        });

        socket.on('timeUpdate', (data) => {
            updateTimer(data.timeLeft, data.isBreak);
            currentRoundEl.textContent = data.round;
        });

        socket.on('roundEnd', (data) => {
            gameActive = false;
            isFishing = false;
            showRoundResult({ round: data.round, ranking: data.ranking, totalRanking: data.totalRanking });
        });

        socket.on('breakStart', (data) => {
            updateTimer(data.timeLeft, true);
        });

        socket.on('gameEnd', (data) => {
            gameActive = false;
            showRoundResult({ isGameEnd: true, totalRanking: data.ranking });
            if (data.winner) {
                addFeedItem(`üèÜ –ü–æ–±–µ–¥–∏—Ç–µ–ª—å: ${data.winner.name}!`);
            }
        });

        socket.on('gameReset', () => {
            stats = { fishCount: 0, totalWeight: 0, roundFish: 0, roundWeight: 0 };
            updateStats();
            players.forEach(p => {
                p.roundWeight = 0;
                p.roundFish = 0;
            });
            updatePlayersList();
        });

        playBtn.addEventListener('click', () => {
            const name = playerNameInput.value.trim() || '–†—ã–±–∞–∫';
            socket.emit('join', name);
            menu.classList.add('hidden');
            game.classList.add('active');
            addFishToWater();
            draw();
        });

        playerNameInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') playBtn.click();
        });

        playerNameInput.focus();
    </script>
</body>
</html>
